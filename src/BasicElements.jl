"""
    DofCost{Class,Nx,Nu,Na,xinod,xfield,uinod,ufield,ainod,
        afield,Tcost,Tcostargs} <: AbstractElement

An element to apply costs on combinations of dofs.  

# Named arguments to the constructor
- `xinod::NTuple{Nx,ùï´}=()`       For each X-dof to enter `cost`, its element-node number.
- `xfield::NTuple{Nx,Symbol}=()` For each X-dof to enter `cost`, its field.
- `uinod::NTuple{Nu,ùï´}=()`       For each U-dof to enter `cost`, its element-node number.
- `ufield::NTuple{Nu,Symbol}=()` For each U-dof to enter `cost`, its field.
- `ainod::NTuple{Na,ùï´}=()`       For each A-dof to enter `cost`, its element-node number.
- `afield::NTuple{Na,Symbol}=()` For each A-dof to enter `cost`, its field.
- `class:Symbol`                 `:A` for cost on A-dofs only, `:I` ("instant") otherwise.
- `cost::Function`               if `class==:I`, `cost(X,U,A,t,costargs...)‚Üí‚Ñù`
                                 if `class==:A`, `cost(A,costargs...)‚Üí‚Ñù` 
                                 `X` and `U` are tuples (derivates of dofs...), and `‚àÇ0(X)`,`‚àÇ1(X)`,`‚àÇ2(X)` 
                                 must be used by `cost` to access the value and derivatives of `X` (resp. `U`) 
- `costargs::NTuple`


# Requestable internal variables
- `cost`, the value of the cost.

# Example
```
ele1 = addelement!(model,DofCost,[nod1],xinod=(1,),field=(:tx1,),
       class=:I,cost=(X,U,A,t)->X[1]^2
```

See also: [`SingleDofCost`](@ref), [`ElementCost`](@ref), [`addelement!`](@ref)  
"""
struct DofCost{Class,Nx,Nu,Na,xinod,xfield,uinod,ufield,ainod,afield,Tcost,Tcostargs} <: AbstractElement
    cost     :: Tcost     
    costargs :: Tcostargs
end
function DofCost(nod::Vector{Node};xinod::NTuple{Nx,ùï´}=(),xfield::NTuple{Nx,Symbol}=(),
                                uinod::NTuple{Nu,ùï´}=(),ufield::NTuple{Nu,Symbol}=(),
                                ainod::NTuple{Na,ùï´}=(),afield::NTuple{Na,Symbol}=(),
                                class::Symbol=:I,cost::Function ,costargs=()) where{Nx,Nu,Na} # :I for "instantaneous" or "integrand" cost.
    (class==:A && (Nx>0||Nu>0)) && muscadeerror("Cost with Class==:A must have zero X-dofs and zero U-dofs") 
    return DofCost{class,Nx,Nu,Na,xinod,xfield,uinod,ufield,ainod,afield,typeof(cost),typeof(costargs)}(cost,costargs)
end
doflist(::Type{<:DofCost{Class,Nx,Nu,Na,xinod,xfield,uinod,ufield,ainod,afield}}) where
                     {Class,Nx,Nu,Na,xinod,xfield,uinod,ufield,ainod,afield} = 
   (inod =(xinod...           ,uinod...           ,ainod...           ), 
    class=(ntuple(i->:X,Nx)...,ntuple(i->:U,Nu)...,ntuple(i->:A,Na)...), 
    field=(xfield...          ,ufield...          ,afield...          ) )
@espy function lagrangian(o::DofCost{:I,Nx,Nu,Na},Œõ,X,U,A,t,œá,œácv,SP,dbg) where{Nx,Nu,Na} 
    ‚òºcost = o.cost(X,U,A,t,o.costargs...)
    return cost,noœá,noFB
end
@espy function lagrangian(o::DofCost{:A,Nx,Nu,Na},Œõ,X,U,A,t,œá,œácv,SP,dbg) where{Nx,Nu,Na} 
    ‚òºcost = o.cost(    A  ,o.costargs...)
    return cost,noœá,noFB
end

"""
    ElementCost{Teleobj,Treq,Tcost,Tcostargs} <: AbstractElement

An element to apply costs on another element's dofs and element-results.  
The other element must *not* be added separatly to the model.  Instead, the 
`ElementType`, and the named arguments to the other element are provided
as input to the `ElementCost` constructor.

# Named arguments to the constructor
- `req`               a request for element-results for `ElementType`, resulting in the output `eleres`
- `cost`              a cost function `cost(eleres,X,U,A,t,costargs...)‚Üí‚Ñù`
                      `X` and `U` are tuples (derivates of dofs...), and `‚àÇ0(X)`,`‚àÇ1(X)`,`‚àÇ2(X)` 
                      must be used by `cost` to access the value and derivatives of `X` (resp. `U`).
                      `X`, `U` and `A` are the degrees of freedom of the element `ElementType`.
- `costargs=(;)`      A named tuple of additional arguments to the cost function 
- `ElementType`       The named of the constructor for the relevant element 
- `elementkwargs...`  Additional named arguments to the `ElementCost` constructor are passed on to the `ElementType` constructor.     


# Requestable internal variables
- `cost`, the value of the cost.

# Example
```
@once cost(eleres,X,U,A,t) = eleres.Fh^2
ele1 = addelement!(model,ElementCost,[nod1];req=@request(Fh),
                   cost=cost,ElementType=AnchorLine,
                   Œõ‚Çòtop=[5.,0,0], x‚Çòbot=[250.,0], L=290., buoyancy=-5e3)
```



See also: [`SingleDofCost`](@ref), [`DofCost`](@ref), [`@request`](@ref) 
"""
struct ElementCost{Teleobj,Treq,Tcost,Tcostargs} <: AbstractElement
    eleobj   :: Teleobj
    req      :: Treq
    cost     :: Tcost     
    costargs :: Tcostargs
end
function ElementCost(nod::Vector{Node};req,cost,costargs=(;),ElementType,elementkwargs...)
    eleobj   = ElementType(nod;elementkwargs...)
    return ElementCost(eleobj,req,cost,costargs)
end
doflist( ::Type{<:ElementCost{Teleobj}}) where{Teleobj} = doflist(Teleobj)
@espy function lagrangian(o::ElementCost, Œõ,X,U,A,t,œá,œácv,SP,dbg)
    L,œá,FB,eleres  = ‚òºgetlagrangian(implemented(o.eleobj)...,o.eleobj,Œõ,X,U,A,t,œá,œácv,SP,(dbg...,via=ElementCost),o.req)
    ‚òºcost          = o.cost(eleres,X,U,A,t,o.costargs...) 
    return L+cost,œá,FB
end    

"""
    SingleDofCost{Derivative,Class,Field,Tcost} <: AbstractElement

An element with a single node, for adding a cost to a given dof.  

# Named arguments to the constructor
- `class::Symbol`, either `:X`, `:U` or `:A`.
- `field::Symbol`.
- `cost::Function`, where `cost(x::‚Ñù,t::‚Ñù[,costargs...]) ‚Üí ‚Ñù` if `class` is `:X` or 
  `:U`, and `cost(x::‚Ñù,[,costargs...]) ‚Üí ‚Ñù` if `class` is `:A`.
- `costargs::NTuple`
- `derivative::Int` 0, 1 or 2 - which derivative of the dof enters the cost	    

# Requestable internal variables
- `cost`, the value of the cost.

# Example
```
using Muscade
model = Model(:TestModel)
node  = addnode!(model,ùï£[0,0])
e     = addelement!(model,SingleDofCost,[node];class=:X,field=:tx,
                    costargs=(3.,),cost=(x,t,three)->(x/three)^2)
```    

See also: [`DofCost`](@ref), [`ElementCost`](@ref)
"""
struct SingleDofCost <: AbstractElement end
function SingleDofCost(nod::Vector{Node};class::Symbol,field::Symbol,cost::Function,derivative=0::ùï´,costargs=()) 
    ‚àÇ=‚àÇn(derivative)
    if     class==:X; DofCost(nod;xinod=(1,),xfield=(field,),class=:I,cost=(X,U,A,t,args...)->cost(‚àÇ(X)[1],t,args...),costargs)
    elseif class==:U; DofCost(nod;uinod=(1,),ufield=(field,),class=:I,cost=(X,U,A,t,args...)->cost(‚àÇ(U)[1],t,args...),costargs)
    elseif class==:A; DofCost(nod;ainod=(1,),afield=(field,),class=:A,cost=(    A,  args...)->cost(A[1]     ,args...),costargs)
    else              muscadeerror("'class' must be :X,:U or :A")
    end
end    

#-------------------------------------------------

"""
    DofLoad{Tvalue,Field} <: AbstractElement

An element to apply a loading term to a single X-dof.  

# Named arguments to the constructor
- `field::Symbol`.
- `value::Function`, where `value(t::‚Ñù) ‚Üí ‚Ñù`.

# Requestable internal variables
- `F`, the value of the load.

# Examples
```
using Muscade
model = Model(:TestModel)
node  = addnode!(model,ùï£[0,0])
e     = addelement!(model,DofLoad,[node];field=:tx,value=t->3t-1)
```    

See also: [`Hold`](@ref), [`DofCost`](@ref)  
"""
struct DofLoad{Field,Tvalue,Targs} <: AbstractElement 
    value      :: Tvalue # Function
    args       :: Targs
end
DofLoad(nod::Vector{Node};field::Symbol,value::Tvalue,args...) where{Tvalue<:Function} = DofLoad{field,Tvalue,typeof(args)}(value,args)
doflist(::Type{<:DofLoad{Field}}) where{Field}=(inod=(1,), class=(:X,), field=(Field,))
@espy function residual(o::DofLoad, X,U,A,t,œá,œácv,SP,dbg) 
    ‚òºF = o.value(t,o.args...)
    return SVector{1}(-F),noœá,noFB
end
#-------------------------------------------------

#McCormick(a,b)= Œ±->a*exp(-(Œ±/b)^2)            # provided as input to solvers, used by their Addin
decided(Œª,g,Œ≥)  = abs(VALUE(Œª)-VALUE(g))/Œ≥    # used by constraint elements

S(Œª,g,Œ≥) = (g+Œª-hypot(g-Œª,2Œ≥))/2 # Modified interior point method's take on KKT's-complementary slackness 

KKT(Œª::ùï£        ,g::ùï£         ,Œ≥::ùï£,Œª‚Çõ,g‚Çõ)                 = 0 # A pseudo-potential with strange derivatives
KKT(Œª::‚àÇ‚Ñù{P,N,R},g::‚àÇ‚Ñù{P,N,R},Œ≥::ùï£,Œª‚Çõ,g‚Çõ) where{P,N,R<:‚Ñù} = ‚àÇ‚Ñù{P,N,R}(0, Œª.x*g.dx + g‚Çõ*S(Œª.x/Œª‚Çõ,g.x/g‚Çõ,Œ≥)*Œª.dx)
KKT(Œª:: ‚Ñù       ,g::‚àÇ‚Ñù{P,N,R},Œ≥::ùï£,Œª‚Çõ,g‚Çõ) where{P,N,R<:‚Ñù} = ‚àÇ‚Ñù{P,N,R}(0, Œª.x*g.dx                           )
KKT(Œª:: ùï£       ,g::‚àÇ‚Ñù{P,N,R},Œ≥::ùï£,Œª‚Çõ,g‚Çõ) where{P,N,R<:‚Ñù} = ‚àÇ‚Ñù{P,N,R}(0, Œª  *g.dx                           )
KKT(Œª::‚àÇ‚Ñù{P,N,R},g:: ‚Ñù       ,Œ≥::ùï£,Œª‚Çõ,g‚Çõ) where{P,N,R<:‚Ñù} = ‚àÇ‚Ñù{P,N,R}(0,            g‚Çõ*S(Œª.x/Œª‚Çõ,g.x/g‚Çõ,Œ≥)*Œª.dx)
function KKT(Œª::‚àÇ‚Ñù{PŒª,NŒª,RŒª},g::‚àÇ‚Ñù{Pg,Ng,Rg},Œ≥::ùï£,Œª‚Çõ,g‚Çõ) where{PŒª,Pg,NŒª,Ng,RŒª<:‚Ñù,Rg<:‚Ñù}
    if PŒª==Pg
        R = promote_type(RŒª,Rg)
        return ‚àÇ‚Ñù{PŒª,NŒª}(convert(R,KKT(Œª.x,g.x,Œ≥,Œª‚Çõ,g‚Çõ)),convert.(R,     Œª.x*g.dx + g‚Çõ*S(Œª.x/Œª‚Çõ,g.x/g‚Çõ,Œ≥)*Œª.dx))
    elseif PŒª> Pg
        R = promote_type(RŒª,typeof(b))
        return ‚àÇ‚Ñù{PŒª,NŒª}(convert(R,KKT(Œª  ,g.x,Œ≥,Œª‚Çõ,g‚Çõ)),convert.(R,     Œª.x*g.dx                            ))
    else
        R = promote_type(typeof(a),Rg)
        return ‚àÇ‚Ñù{Pg,Ng}(convert(R,KKT(Œª.x,g  ,Œ≥,Œª‚Çõ,g‚Çõ)),convert.(R,                g‚Çõ*S(Œª.x/Œª‚Çõ,g.x/g‚Çõ,Œ≥)*Œª.dx))
    end
end

#-------------------------------------------------

"""
    off(t) ‚Üí :off

A function which for any value `t` returns the symbol `off`.  Usefull for specifying
the keyword argument `mode=off` in adding an element of type ``DofConstraint` to
a `Model`.

    See also: [`DofConstraint`](@ref), [`ElementConstraint`](@ref), [`equal`](@ref), [`positive`](@ref)
"""
off(t)     = :off
"""
    equal(t) ‚Üí :equal

A function which for any value `t` returns the symbol `equal`.  Usefull for specifying
the keyword argument `mode=equal` in adding an element of type ``DofConstraint` to
a `Model`.

See also: [`DofConstraint`](@ref), [`ElementConstraint`](@ref), [`off`](@ref), [`positive`](@ref)
"""
equal(t)   = :equal
"""
    positive(t) ‚Üí :positive

A function which for any value `t` returns the symbol `positive`.  Usefull for specifying
the keyword argument `mode=positive` in adding an element of type ``DofConstraint` to
a `Model`.

See also: [`DofConstraint`](@ref), [`ElementConstraint`](@ref), [`off`](@ref), [`equal`](@ref)
"""
positive(t) = :positive
"""
    DofConstraint{Œªclass,Nx,Nu,Na,xinod,xfield,uinod,ufield,ainod,
        afield,Œªinod,Œªfield,Tg,Tmode} <: AbstractElement

An element to apply physical/optimisation equality/inequality constraints on dofs. 

The constraints are holonomic, i.e. they apply to the values, not the time derivatives, of the involved dofs. 
This element is very general but not very user-friendly to construct, factory functions are provided for better useability. 
The sign convention is that the gap `g‚â•0` and the Lagrange multiplier `Œª‚â•0`.

This element can generate three classes of constraints, depending on the input argument `Œªclass`.
- `Œªclass=:X` Physical constraint.  In mechanics, the Lagrange multiplier dof is a 
   generalized force, dual of the gap. The gap function must be of the form `gap(x,t,gargs...)`.
- `Œªclass=:U` Time varying optimisation constraint. For example: find `A`-parameters so that
   at all times, the response does not exceed a given criteria. The gap function must be of the form   
   `gap(x,u,a,t,gargs...)`.
- `Œªclass=:A` Time invariant optimisation constraint. For example: find `A`-parameters such that
   `A[1]+A[2]=gargs.somevalue`. The gap function must be of the form `gap(a,gargs...)`.

# Named arguments to the constructor
- `xinod::NTuple{Nx,ùï´}=()`       For each X-dof to be constrained, its element-node number.
- `xfield::NTuple{Nx,Symbol}=()` For each X-dof to be constrained, its field.
- `uinod::NTuple{Nu,ùï´}=()`       For each U-dof to be constrained, its element-node number.
- `ufield::NTuple{Nu,Symbol}=()` For each U-dof to be constrained, its field.
- `ainod::NTuple{Na,ùï´}=()`       For each A-dof to be constrained, its element-node number.
- `afield::NTuple{Na,Symbol}=()` For each A-dof to be constrained, its field.
- `Œªinod::ùï´`                     The element-node number of the Lagrange multiplier.
- `Œªclass::Symbol`               The class (`:X`,`:U` or `:A`) of the Lagrange multiplier. 
                                 See the explanation above for classes of constraints
- `Œªfield::Symbol`               The field of the Lagrange multiplier.
- `g‚Çõ::ùï£=1.`                      A scale for the gap.
- `Œª‚Çõ::ùï£=1.`                      A scale for the Lagrange multiplier.
- `gap::Function`                The gap function.
- `gargs::NTuple`                Additional inputs to the gap function.
- `mode::Function`               where `mode(t::‚Ñù) -> Symbol`, with value `:equal`, 
                                 `:positive` or `:off` at any time. An `:off` constraint 
                                 will set the Lagrange multiplier to zero.

# Example
```jldoctest; output = false
using Muscade
model           = Model(:TestModel)
n1              = addnode!(model,ùï£[0]) 
e1              = addelement!(model,DofConstraint,[n1],xinod=(1,),xfield=(:t1,),
                              Œªinod=1, Œªclass=:X, Œªfield=:Œª1,gap=(x,t)->x[1]+.1,
                              mode=positive)
e2              = addelement!(model,QuickFix  ,[n1],inod=(1,),field=(:t1,),
                              res=(x,u,a,t)->0.4x.+.08+.5x.^2)
initialstate    = initialize!(model)
state           = solve(StaticX;initialstate,time=[0.],verbose=false) 
X               = state[1].X[1]

# output

2-element Vector{Float64}:
 -0.09999997108612142
  0.04500000867027695
```    

See also: [`Hold`](@ref), [`ElementConstraint`](@ref), [`off`](@ref), [`equal`](@ref), [`positive`](@ref)
"""
struct DofConstraint{Œªclass,Nx,Nu,Na,xinod,xfield,uinod,ufield,ainod,afield,Œªinod,Œªfield,Tg,Tgargs,Tmode} <: AbstractElement
    gap      :: Tg    # Class==:X gap(x,t,gargs...) ,Class==:U  gap(x,u,a,t,gargs...), Class==:A gap(a,gargs...) 
    gargs    :: Tgargs
    mode     :: Tmode # mode(t)->symbol, or Symbol for Aconstraints
    g‚Çõ        :: ùï£
    Œª‚Çõ        :: ùï£  
end
function DofConstraint(nod::Vector{Node};xinod::NTuple{Nx,ùï´}=(),xfield::NTuple{Nx,Symbol}=(),
                                      uinod::NTuple{Nu,ùï´}=(),ufield::NTuple{Nu,Symbol}=(),
                                      ainod::NTuple{Na,ùï´}=(),afield::NTuple{Na,Symbol}=(),
                                      Œªinod::ùï´, Œªclass::Symbol, Œªfield::Symbol,
                                      g‚Çõ::ùï£=1.,Œª‚Çõ::ùï£=1.,
                                      gap::Function ,gargs=(),mode::Function) where{Nx,Nu,Na} 
    (Œªclass==:X && (Nu>0||Na>0)) && muscadeerror("Constraints with Œªclass=:X must have zero U-dofs and zero A-dofs") 
    (Œªclass==:A && (Nx>0||Nu>0)) && muscadeerror("Constraints with Œªclass=:A must have zero X-dofs and zero U-dofs") 
    return DofConstraint{Œªclass,Nx,Nu,Na,xinod,xfield,uinod,ufield,ainod,afield,Œªinod,Œªfield,
                       typeof(gap),typeof(gargs),typeof(mode)}(gap,gargs,mode,g‚Çõ,Œª‚Çõ)
end
doflist(::Type{<:DofConstraint{Œªclass,Nx,Nu,Na,xinod,xfield,uinod,ufield,ainod,afield,Œªinod,Œªfield}}) where
                            {Œªclass,Nx,Nu,Na,xinod,xfield,uinod,ufield,ainod,afield,Œªinod,Œªfield} = 
   (inod =(xinod...           ,uinod...           ,ainod...           ,Œªinod ), 
    class=(ntuple(i->:X,Nx)...,ntuple(i->:U,Nu)...,ntuple(i->:A,Na)...,Œªclass), 
    field=(xfield...          ,ufield...          ,afield...          ,Œªfield)) 
@espy function residual(o::DofConstraint{:X,Nx}, X,U,A,t,œá,œácv,SP,dbg) where{Nx}
    Œ≥          = default{:Œ≥}(SP,0.)
    P,g‚Çõ,Œª‚Çõ     = constants(‚àÇ0(X)),o.g‚Çõ,o.Œª‚Çõ
    x,‚òºŒª       = ‚àÇ0(X)[SVector{Nx}(1:Nx)], ‚àÇ0(X)[Nx+1]   
    x‚àÇ         = variate{P,Nx}(x) 
    ‚òºgap,g‚àÇx   = value_‚àÇ{P,Nx}(o.gap(x‚àÇ,t,o.gargs...)) 
    if         o.mode(t)==:equal;    return SVector{Nx+1}((       -g‚àÇx*Œª)...,-gap              ) ,noœá,(Œ±=‚àû                    ,)
    elseif     o.mode(t)==:positive; return SVector{Nx+1}((       -g‚àÇx*Œª)...,-g‚Çõ*S(Œª/Œª‚Çõ,gap/g‚Çõ,Œ≥)) ,noœá,(Œ±=decided(Œª/Œª‚Çõ,gap/g‚Çõ,Œ≥),)
    elseif     o.mode(t)==:off;      return SVector{Nx+1}(ntuple(i->0,Nx)...,-g‚Çõ/Œª‚Çõ*Œª           ) ,noœá,(Œ±=‚àû                    ,)
    end
end
@espy function lagrangian(o::DofConstraint{:U,Nx,Nu,Na}, Œõ,X,U,A,t,œá,œácv,SP,dbg) where{Nx,Nu,Na}
    Œ≥          = default{:Œ≥}(SP,0.)
    x,u,a,‚òºŒª   = ‚àÇ0(X),‚àÇ0(U)[SVector{Nu}(1:Nu)],A,‚àÇ0(U)[Nu+1]
    ‚òºgap       = o.gap(x,u,a,t,o.gargs...)
    if         o.mode(t)==:equal;    return -gap*Œª                  ,noœá,(Œ±=‚àû                        ,)
    elseif     o.mode(t)==:positive; return -KKT(Œª,gap,Œ≥,o.Œª‚Çõ,o.g‚Çõ)  ,noœá,(Œ±=decided(Œª/o.Œª‚Çõ,gap/o.g‚Çõ,Œ≥),)
    elseif     o.mode(t)==:off;      return -o.g‚Çõ/(2o.Œª‚Çõ)*Œª^2        ,noœá,(Œ±=‚àû                        ,)  
    end
end
@espy function lagrangian(o::DofConstraint{:A,Nx,Nu,Na}, Œõ,X,U,A,t,œá,œácv,SP,dbg) where{Nx,Nu,Na}
    Œ≥          = default{:Œ≥}(SP,0.)
    a,‚òºŒª       = A[SVector{Na}(1:Na)],A[    Na+1] 
    ‚òºgap       = o.gap(a,o.gargs...)
    if         o.mode(t)==:equal;    return -gap*Œª                  ,noœá,(Œ±=‚àû                        ,) 
    elseif     o.mode(t)==:positive; return -KKT(Œª,gap,Œ≥,o.Œª‚Çõ,o.g‚Çõ)  ,noœá,(Œ±=decided(Œª/o.Œª‚Çõ,gap/o.g‚Çõ,Œ≥),)
    elseif     o.mode(t)==:off;      return -o.g‚Çõ/(2o.Œª‚Çõ)*Œª^2        ,noœá,(Œ±=‚àû                        ,)   
    end
end


#-------------------------------------------------

"""
    Hold <: AbstractElement

An element to set a single X-dof to zero.  

# Named arguments to the constructor
- `field::Symbol`. The field of the X-dof to constraint.
- `Œªfield::Symbol=Symbol(:Œª,field)`. The field of the Lagrange multiplier.

# Example
```
using Muscade
model = Model(:TestModel)
node  = addnode!(model,ùï£[0,0])
e     = addelement!(model,Hold,[node];field=:tx)
```    

See also: [`DofConstraint`](@ref), [`DofLoad`](@ref), [`DofCost`](@ref) 
"""
struct Hold <: AbstractElement end  
function Hold(nod::Vector{Node};field::Symbol,Œªfield::Symbol=Symbol(:Œª,field)) 
    gap(v,t)=v[1]
    return DofConstraint{:X     ,1, 0, 0, (1,),(field,),(),   (),    (),   (),    1,    Œªfield, typeof(gap),typeof(()),typeof(equal)}(gap,(),equal,1.,1.)
end

#-------------------------------------------------

"""
    ElementConstraint{Teleobj,Œªinod,Œªfield,Nu,Treq,Tg,Tgargs,Tmode} <: AbstractElement

An element to apply optimisation equality/inequality constraints on the element-results of 
another element. The other element must *not* be added separatly to the model.  Instead, the 
`ElementType`, and the named arguments to the other element are provided as input to the 
`ElementConstraint` constructor.

This element generates a time varying optimisation constraint. For example: find `A`-parameters so that
   at all times, the element-result von-Mises stress does not exceed a given value. 

The Lagrangian multiplier introduced by this optimisation constraint is of class :U   

# Named arguments to the constructor
- `Œªinod::ùï´`            The element-node number of the Lagrange multiplier.
- `Œªfield::Symbol`      The field of the Lagrange multiplier.
- `req`                 A request for element-results, see [`@request`](@ref).
- `g‚Çõ::ùï£=1.`             A scale for the gap.
- `Œª‚Çõ::ùï£=1.`             A scale for the Lagrange multiplier.
- `gap`                 a gap function `gap(eleres,X,U,A,t,gargs...)‚Üí‚Ñù`
                        `X` and `U` are tuples (derivates of dofs...), and `‚àÇ0(X)`,`‚àÇ1(X)`,`‚àÇ2(X)` 
                        must be used by `cost` to access the value and derivatives of `X` (resp. `U`).
                        `X`, `U` and `A` are the degrees of freedom of the element `ElementType`.
- `gargs::NTuple`       Additional inputs to the gap function. 

- `mode::Function`      where `mode(t::‚Ñù) -> Symbol`, with value `:equal`, 
                        `:positive` or `:off` at any time. An `:off` constraint 
                        will set the Lagrange multiplier to zero.
- `ElementType`         The named of the constructor for the relevant element 
- `elementkwargs...`    Additional named arguments to the `ElementCost` constructor are passed on to the `ElementType` constructor.     




# Example

```
@once gap(eleres,X,U,A,t) = eleres.Fh^2
ele1 = addelement!(model,ElementCoonstraint,[nod1];req=@request(Fh),
                   gap,Œªinod=1,Œªfield=:Œª,mode=equal, 
                   ElementType=AnchorLine,Œîx‚Çòtop=[5.,0,0], x‚Çòbot=[250.,0], 
                   L=290., buoyancy=-5e3)
```

See also: [`Hold`](@ref), [`DofConstraint`](@ref), [`off`](@ref), [`equal`](@ref), [`positive`](@ref), [`@request`](@ref)
"""
struct ElementConstraint{Teleobj,Œªinod,Œªfield,Nu,Treq,Tg,Tgargs,Tmode} <: AbstractElement
    eleobj   :: Teleobj
    req      :: Treq
    gap      :: Tg    
    gargs    :: Tgargs
    mode     :: Tmode 
    g‚Çõ        :: ùï£
    Œª‚Çõ        :: ùï£  
end
function ElementConstraint(nod::Vector{Node};Œªinod::ùï´, Œªfield::Symbol,
    req,gap::Function,gargs=(;),mode::Function,g‚Çõ::ùï£=1.,Œª‚Çõ::ùï£=1.,ElementType,elementkwargs...)
    eleobj   = ElementType(nod;elementkwargs...)
    Nu       = getndof(typeof(eleobj),:U)
    return ElementConstraint{typeof(eleobj),Œªinod,Œªfield,Nu,typeof(req),typeof(gap),typeof(gargs),typeof(mode)}(eleobj,req,gap,gargs,mode,g‚Çõ,Œª‚Çõ)
end
doflist( ::Type{<:ElementConstraint{Teleobj,Œªinod,Œªfield}}) where{Teleobj,Œªinod,Œªfield} =
    (inod =(doflist(Teleobj).inod... ,Œªinod),
     class=(doflist(Teleobj).class...,:U),
     field=(doflist(Teleobj).field...,Œªfield))
@espy function lagrangian(o::ElementConstraint{Teleobj,Œªinod,Œªfield,Nu}, Œõ,X,U,A,t,œá,œácv,SP,dbg) where{Teleobj,Œªinod,Œªfield,Nu} 
    Œ≥          = default{:Œ≥}(SP,0.)
    u          = getsomedofs(U,SVector{Nu}(1:Nu)) 
    ‚òºŒª         = ‚àÇ0(U)[Nu+1]
    L,œán,FB,eleres  = getlagrangian(implemented(o.eleobj)...,o.eleobj,Œõ,X,u,A,t,œá,œácv,SP,(dbg...,via=ElementConstraint),o.req)
    ‚òºresreq = eleres
    ‚òºgap       = o.gap(eleres,X,u,A,t,o.gargs...)
    if         o.mode(t)==:equal;    return L-gap*Œª                  ,noœá,(Œ±=‚àû                        ,)
    elseif     o.mode(t)==:positive; return L-KKT(Œª,gap,Œ≥,o.Œª‚Çõ,o.g‚Çõ)  ,noœá,(Œ±=decided(Œª/o.Œª‚Çõ,gap/o.g‚Çõ,Œ≥),)
    elseif     o.mode(t)==:off;      return L-o.g‚Çõ/(2o.Œª‚Çõ)*Œª^2        ,noœá,(Œ±=‚àû                        ,)  
    end
end

#-------------------------------------------------

"""
    QuickFix <: AbstractElement

An element for creating simple elements with "one line" of code.  
Elements thus created have several limitations:
- no internal state.
- no initialisation.
- physical elements with only X-dofs.
- only `R` can be espied.
The element is intended for testing.  Muscade-based applications should not include this in their API. 

# Named arguments to the constructor
- `inod::NTuple{Nx,ùï´}`. The element-node numbers of the X-dofs.
- `field::NTuple{Nx,Symbol}`. The fields of the X-dofs.
- `res::Function`, where `res(X::‚Ñù1,X‚Ä≤::‚Ñù1,X‚Ä≥::‚Ñù1,t::‚Ñù) ‚Üí ‚Ñù1`, the residual.

# Examples
A one-dimensional linear elastic spring with stiffness 2.
```jldoctest; output = false
using Muscade
model = Model(:TestModel)
node1  = addnode!(model,ùï£[0])
node2  = addnode!(model,ùï£[1])
e = addelement!(model,QuickFix,[node1,node2];inod=(1,2),field=(:tx1,:tx1),
                res=(X,X‚Ä≤,X‚Ä≥,t)->Svector{2}(2*(X[1]-X[2]),2*(X[2]-X[1])) )

# output

Muscade.EleID(1, 1)                       
```    
"""
struct QuickFix{Nx,inod,field,Tres} <: AbstractElement
    res        :: Tres    # R = res(X,X‚Ä≤,X‚Ä≥,t)
end
QuickFix(nod::Vector{Node};inod::NTuple{Nx,ùï´},field::NTuple{Nx,Symbol},res::Function) where{Nx} = QuickFix{Nx,inod,field,typeof(res)}(res)
doflist(::Type{<:QuickFix{Nx,inod,field}}) where{Nx,inod,field} = (inod =inod,class=ntuple(i->:X,Nx),field=(field)) 
@espy function residual(o::QuickFix, X,U,A, t,œá,œácv,SP,dbg) 
    ‚òºR = o.res(‚àÇ0(X),‚àÇ1(X),‚àÇ2(X),t)
    return R,noœá,noFB
end

#-------------------------------------------------
